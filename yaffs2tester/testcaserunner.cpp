/* Generated by test case generator for yaffs testing */
extern "C" {
#include "yaffsfs.h"
}
#define FILE_SIZE 1024*1024
char rwbuf[FILE_SIZE];
int rets[5210];
#define SIZE 1024*1024
char tsbuf[SIZE];

#include "yaffstester.h"


extern "C" void open_trace_db(const char* dbname, 
const char* blockmeta, const char* branchmeta, const char* pathmeta, const char* predmeta, const char* stmtpredmeta);
extern "C" void close_trace_db();

extern "C" void begin_transaction();
extern "C" void commit_transaction();

extern "C" void begin_trace_session(char* type, int addnew);
extern "C" long end_trace_session(char* type);

int parseflags(char* f);
int parsemode(char* m);
void runtestcasefile(char* testcasefile, char*output);

/* used by yaffs2 code, TODO, reset it */
int random_seed;
int simulate_power_failure;
extern int yaffs_trace_mask;

#define OUTPUT_SIZE 100000
char output[OUTPUT_SIZE];
int main(int argc, char* argv[]) {
    int start = 0, num = 1;
    int gencov = 0;
    int i = 1;
    char* instype = 0;
   
    char* testcasefile = argv[1];

    // yaffs_trace_mask = 0;
    // const char* covdbname = 0;
    // while( i < argc ) {
    //     if( strcmp(argv[i], "-start") == 0 ) {
    //         start = atoi(argv[i+1] );
    //         i += 2;
    //     }
    //     else if( strcmp(argv[i], "-num") == 0 ) {
    //         num = atoi(argv[i+1]);
    //         i += 2;
    //     }
    //     else if( strcmp(argv[i], "-c") == 0 ) {
    //         gencov = 1;
    //         i += 1;
    //     }
    //     else if( strcmp(argv[i], "-instype") == 0 ) {
    //         instype = argv[i+1];
    //         i += 2;
    //     }
    //     else if( strcmp(argv[i], "-testcasefile") == 0) {
    //         testcasefile = argv[i+1];
    //         i += 2;
    //     }
    //     else if( strcmp(argv[i], "-covdbname") == 0) {
    //         covdbname = argv[i+1];
    //         i += 2;            
    //     }
    // }
    while(start < num) {
        memset(output, 0, OUTPUT_SIZE);
#ifndef NO_COVERAGE
        if(gencov) {
            open_trace_db(covdbname, "blockcount", "branchcount", "cfginfofile", "blockpredcount", "stmtpredcount");
            begin_trace_session(instype, 1);
        }
#endif
        runtestcasefile(testcasefile, output);

        start++;
#ifndef NO_COVERAGE        
        if(gencov) {
            end_trace_session(instype);
            close_trace_db();
        }
#endif
        if( !gencov) {
	 fprintf(stdout, "%s\n", output);
/*
            FILE* fp = fopen("testresult.txt", "a+");
            if( fp ) {
                fprintf(fp, "%s\n", output);
                fclose(fp);
            }
*/
        }
    }
    return 0;
}

int parseflags(char* f) {
    int mode = 0;
    char* pch = strtok(f, "|");
    while( pch ) {
        if( strcmp(pch, "O_RDONLY") == 0) {
            mode |= O_RDONLY;
        } 
        else if( strcmp(pch, "O_WRONLY") == 0) {
            mode |= O_WRONLY;
        }
        else if( strcmp(pch, "O_RDWR") == 0) {
            mode |= O_RDWR;
        }
        else if( strcmp(pch, "O_EXCL") == 0) {
            mode |= O_EXCL;
        }
        else if( strcmp(pch, "O_TRUNC") == 0) {
            mode |= O_TRUNC;
        }
        else if( strcmp(pch, "O_APPEND") == 0) {
            mode |= O_APPEND;
        }
        pch = strtok(NULL, "|");
    }
    return mode;
}

int parsemode(char* m) {
    int mode = 0;
    char* pch = strtok(m, "|");
    while( pch ) {
        if( strcmp(pch, "S_IREAD") == 0) {
            mode |= S_IREAD;
        } 
        else if( strcmp(pch, "S_IWRITE") == 0) {
            mode |= S_IWRITE;
        }       
        pch = strtok(NULL, "|");
    }
    return mode;
}

void runtestcase( yaffs_test_case& testcase, char* output) {
    int fds[50000];
    memset(fds, 0, sizeof(int)*50000);
    yaffs_DIR* dirs[50000];
    memset(dirs, 0, sizeof(yaffs_DIR*)*50000);
    memset(rets, 0, 10);
    //int max_fds = 0;
    struct yaffs_stat st_buff;
    int j;
    int nr = 0;
    //yaffs_start_up();
    //yaffs_mount("/yaffs2");
    for( int i = 0; i < testcase.api_calls.size(); i++) {
        yaffs_api_call call = testcase.api_calls[i];
        switch( call.api_id ) {
            case STARTUP:
                {
                    rets[nr++] = yaffs_start_up();
                }
                break;
            case MOUNT:
                {
                    const char* mpnt = call.parameters[0].get_str().c_str();
                    rets[nr++] = yaffs_mount(mpnt);
                }
                break;
            case UNMOUNT:
                {
                    const char* mpnt = call.parameters[0].get_str().c_str();
                    rets[nr++] = yaffs_unmount(mpnt);
                }
                break;
            case OPEN:
                {
                    const char* path = call.parameters[0].get_str().c_str();
                    int iflag = call.parameters[1].get_int();
                    int imode = call.parameters[2].get_int();
                    int idxfd = call.parameters[3].get_int();
                    rets[nr++] = fds[idxfd] = yaffs_open(path, iflag, imode);
                }
                break;
            case CLOSE:
                {
                    int idxfd = call.parameters[0].get_int();
                    rets[nr++] = yaffs_close(fds[idxfd]);
                }
                break;
            case MKDIR:
                {
                    const char* path = call.parameters[0].get_str().c_str();
                    int imode = call.parameters[1].get_int();
                    rets[nr++] = yaffs_mkdir(path, imode);
                }
                break;
            case RMDIR:
                {
                    const char* path = call.parameters[0].get_str().c_str();
                    rets[nr++] = yaffs_rmdir(path);
                }
                break;
            case LSEEK:
                {
                    int idxfd = call.parameters[0].get_int();
                    int ioffset = call.parameters[1].get_int();
                    int whera = call.parameters[2].get_int();
                    rets[nr++] = yaffs_lseek(fds[idxfd], ioffset, whera);
                }
                break;
            case TRUNCATE:
                {
                    const char* path = call.parameters[0].get_str().c_str();
                    int ioffset = call.parameters[1].get_int();
                    rets[nr++] = yaffs_truncate(path, ioffset);
                }
                break;
            case FTRUNCATE:
                {
                    int idxfd = call.parameters[0].get_int();
                    int ioffset = call.parameters[1].get_int();
                    rets[nr++] = yaffs_ftruncate(fds[idxfd], ioffset);
                }
                break;                    
            case STAT:
                {
                    const char* path = call.parameters[0].get_str().c_str();
                    rets[nr++] = yaffs_stat(path, &st_buff);
                }
                break;
            case FSTAT:
                {
                    int idxfd = call.parameters[0].get_int();
                    rets[nr++] = yaffs_fstat(fds[idxfd], &st_buff);
                }
                break; 
            case LSTAT:
                {
                    const char* path = call.parameters[0].get_str().c_str();
                    rets[nr++] = yaffs_lstat(path, &st_buff);
                }
                break;
            case READ:
                {
                    int idxfd = call.parameters[0].get_int();
                    int inbyte = call.parameters[1].get_int();
                    rets[nr++] = yaffs_read(fds[idxfd], rwbuf, inbyte);
                }
                break;
            case WRITE:
                {
                    int idxfd = call.parameters[0].get_int();
                    int inbyte = call.parameters[1].get_int();
                    rets[nr++] = yaffs_write(fds[idxfd], rwbuf, inbyte);
                }
                break;
            case FREESPACE:
                {
                    const char* path = call.parameters[0].get_str().c_str();
                    rets[nr++] = yaffs_freespace(path);                 
                    /*int freespace = yaffs_freespace(path);
                    if( freespace > 0) {
                        rets[nr++] = 1;                    
                    }
                    else {
                        rets[nr++] = freespace;
                    }*/
                    
                }
                break;
            case OPENDIR:
                {
                    const char* path = call.parameters[0].get_str().c_str();
                    int idxdir = call.parameters[1].get_int();
                    dirs[idxdir] = yaffs_opendir(path);
                    if( dirs[idxdir] == NULL ) {
                        rets[nr++] = 0;
                    }
                    else {
                        rets[nr++] = 1;
                    }
                }
                break;
            case READDIR:
                {
                    int idxdir = call.parameters[0].get_int();
                    if( dirs[idxdir] != NULL ) {
                        yaffs_readdir( dirs[idxdir] );
                    } 
                }
                break;
            case REWINDDIR:
                {
                    int idxdir = call.parameters[0].get_int();
                    if( dirs[idxdir] != NULL ) {
                        yaffs_rewinddir( dirs[idxdir] );
                    } 
                }
                break;
            case CLOSEDIR:
                {
                    int idxdir = call.parameters[0].get_int();
                    if( dirs[idxdir] != NULL ) {
                        yaffs_closedir( dirs[idxdir] );
                        dirs[idxdir] = NULL;
                    } 
                }
                break;
            case LINK:
                {
                    const char* oldpath = call.parameters[0].get_str().c_str();
                    const char* newpath = call.parameters[1].get_str().c_str();
                    rets[nr++] = yaffs_link(oldpath, newpath);
                }
                break;
            case SYMLINK:
                {
                    const char* oldpath = call.parameters[0].get_str().c_str();
                    const char* newpath = call.parameters[1].get_str().c_str();
                    rets[nr++] = yaffs_symlink(oldpath, newpath);
                }
                break; 
            case READLINK:
                {
                    const char* oldpath = call.parameters[0].get_str().c_str();
                    int isize = call.parameters[1].get_int();
                    rets[nr++] = yaffs_readlink(oldpath, rwbuf, isize);
                }
                break;
            case UNLINK:
                {
                    const char* oldpath = call.parameters[0].get_str().c_str();
                    rets[nr++] = yaffs_unlink(oldpath);
                }
                break;
            case RENAME:
                {
                    const char* oldpath = call.parameters[0].get_str().c_str();
                    const char* newpath = call.parameters[1].get_str().c_str();
                    rets[nr++] = yaffs_rename(oldpath, newpath);
                }
                break;
            case CHMOD:
                {
                    const char* path = call.parameters[0].get_str().c_str();
                    int imode = call.parameters[1].get_int();
                    rets[nr++] = yaffs_chmod(path, imode);
                }
                break;
            case FCHMOD:
                {
                    int idxfd = call.parameters[0].get_int();
                    int imode = call.parameters[1].get_int();
                    rets[nr++] = yaffs_fchmod( fds[idxfd], imode);
                }
                break;
            case FSYNC:
                {
                    int idxfd = call.parameters[0].get_int();
                    rets[nr++] = yaffs_fsync(fds[idxfd]);                            
                }
                break;
            case FDATASYNC:
                {
                    int idxfd = call.parameters[0].get_int();
                    rets[nr++] = yaffs_fdatasync(fds[idxfd]);                            
                }
                break;
            case ACCESS:
                {
                    const char* path = call.parameters[0].get_str().c_str();
                    int imode  = call.parameters[1].get_int();
                    rets[nr++] = yaffs_access(path, imode);
                }
                break;
            case DUP:
                {
                    int idxfd = call.parameters[0].get_int();
                    int idxnewfd = call.parameters[1].get_int();
                    int newfd = yaffs_dup(fds[idxfd]);
                    fds[idxnewfd] = newfd;
                    if( newfd >= 0) {
                        rets[nr++] = 0;
                    }
                    else {
                        rets[nr++] = -1;
                    }
                }
                break;
            case PREAD:
                {
                    int idxfd = call.parameters[0].get_int();
                    int inbyte = call.parameters[1].get_int();
                    int inoffset = call.parameters[2].get_int();
                    rets[nr++] = yaffs_pread(fds[idxfd], rwbuf, inbyte, inoffset);
                }
                break;
            case PWRITE:
                {
                    int idxfd = call.parameters[0].get_int();
                    int inbyte = call.parameters[1].get_int();
                    int inoffset = call.parameters[2].get_int();
                    rets[nr++] = yaffs_pwrite(fds[idxfd], rwbuf, inbyte, inoffset);
                }
                break;
            case UTIME://int yaffs_utime(const YCHAR *path, const struct yaffs_utimbuf *buf);
                {
                    struct yaffs_utimbuf utbuf;
                    const char* path = call.parameters[0].get_str().c_str();
                    rets[nr++] = yaffs_utime(path, &utbuf);
                }
                break;           
            case FUTIME://int yaffs_futime(int fd, const struct yaffs_utimbuf *buf);
                {
                    struct yaffs_utimbuf utbuf; 
                    int idxfd = call.parameters[0].get_int();
                    rets[nr++] = yaffs_futime(fds[idxfd], &utbuf);
                }
                break;            
            case FLUSH://int yaffs_flush(int fd) ;
                {
                    int idxfd = call.parameters[0].get_int();
                    rets[nr++] = yaffs_flush(fds[idxfd]);
                }
                break;
            case SYNC://int yaffs_sync(const YCHAR *path) ;
                {
                    const char* path = call.parameters[0].get_str().c_str();
                    rets[nr++] = yaffs_sync(path);                                
                }
                break;
            case TOTALSPACE://loff_t yaffs_totalspace(const YCHAR *path);
                {
                    const char* path = call.parameters[0].get_str().c_str();
                    rets[nr++] = yaffs_totalspace(path);
                    /*int totalspace = yaffs_totalspace(path);
                    if( totalspace > 0) {
                        rets[nr++] = 1;                    
                    }
                    else {
                        rets[nr++] = totalspace;
                    }*/    
                }
                break;
            case INODECOUNT://int yaffs_inodecount(const YCHAR *path);
                {
                    const char* path = call.parameters[0].get_str().c_str();
                    rets[nr++] = yaffs_inodecount(path);        
                }
                break;
            case NHANDLES://int yaffs_n_handles(const YCHAR *path);
                {
                    const char* path = call.parameters[0].get_str().c_str();
                    rets[nr++] = yaffs_n_handles(path);        
                }
                break;    
#ifndef __LESS_API                
            case SETXATTR://int yaffs_setxattr(const char *path, const char *name, const void *data, int size, int flags);
                {
                }
                break;        
            case LSETXATTR://int yaffs_lsetxattr(const char *path, const char *name, const void *data, int size, int flags);
                {
                }
                break;       
            case FSETXATTR://int yaffs_fsetxattr(int fd, const char *name, const void *data, int size, int flags);
                {
                }
                break;       
            case GETXATTR://int yaffs_getxattr(const char *path, const char *name, void *data, int size);
                {
                }
                break;        
            case LGETXATTR://int yaffs_lgetxattr(const char *path, const char *name, void *data, int size);
                {
                }
                break;       
            case FGETXATTR://int yaffs_fgetxattr(int fd, const char *name, void *data, int size);
                {
                }
                break;       
            case REMOVEXATTR://int yaffs_removexattr(const char *path, const char *name);
                {
                }
                break;     
            case LREMOVEXATTR://int yaffs_lremovexattr(const char *path, const char *name);
                {
                }
                break;    
            case FREMOVEXATTR://int yaffs_fremovexattr(int fd, const char *name);
                {
                }
                break;    
            case LISTXATTR://int yaffs_listxattr(const char *path, char *list, int size);
                {
                }
                break;      
            case LLISTXATTR://int yaffs_llistxattr(const char *path, char *list, int size);
                {
                }
                break;      
            case FLISTXATTR://int yaffs_flistxattr(int fd, char *list, int size);
                {
                }
                break; 
#endif                
            default:
                break;
            }

    }
    for(j=0;j<nr;j++) { 
        sprintf(output+strlen(output), "%d,", rets[j]);
    }
    int x = yaffs_freespace("/yaffs2");
    //printf("freespace = %d\n",x);
}

void runtestcasefile(char* testcasefile, char*output) {
    char testcasebuf[1024];
    //int fds[5000];
    //memset(fds, 0, sizeof(int)*5000);
    //yaffs_DIR* dirs[5000];
    //memset(dirs, 0, sizeof(yaffs_DIR*)*5000);
    //memset(rets, 0, 10);
    //int max_fds = 0;
    //struct yaffs_stat st_buff;
    //int j;
    //int nr = 0;
    //rets[nr++]=yaffs_start_up();
    //rets[nr++]=yaffs_mount("/yaffs2");    
    // repeatly read lines from test case file and run it.
    std::vector<std::string> strs;
    FILE* fp = fopen(testcasefile, "r");
    if( fp != NULL ) {
        while( !feof(fp) ) {
            char* p = fgets(testcasebuf, 1024, fp);
            if( p != NULL ) {
                char* r = strstr(p, "\n");
                if( r ) { 
                    *r = 0;
                }
                r = strstr(p, "\r");
                if( r ) { 
                    *r = 0;
                }
                if( strstr(p, "==") == NULL) {
                    strs.push_back(p);
                    //char* p = testcasebuf;
                    //char* pch = strtok(p, ",");
                    //int api = atoi(pch);
                    ////////////////////////////
                    
                }
            }
        }
        fclose(fp);
        
        yaffs_test_case testcase;
        testcase.fromstrings( strs );
        runtestcase( testcase, output);
   }
    
    //rets[nr++]=yaffs_unmount("/yaffs2");
    //for(j=0;j<nr;j++) { 
    //    sprintf(output+strlen(output), "%d,", rets[j]);
    //}
}
